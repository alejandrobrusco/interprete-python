package com.language.parser;

import java.util.*;
import java_cup.runtime.*;
import com.language.model.*;
import com.language.exceptions.*;


terminal String PLUS;
terminal String MINUS;
terminal String POW;
terminal String MULT;
terminal String DIV_INT;
terminal String DIV;
terminal String MOD;

terminal String LPARAN;
terminal String RPARAN;
terminal String LBRACKET;
terminal String RBRACKET;

terminal String BAND;
terminal String BOR;
terminal String BXOR;
terminal String BNOT;
terminal String BLSHIFT;
terminal String BRSHIFT;

terminal String TRUE;
terminal String FALSE;

terminal String AND;
terminal String OR;
terminal String NOT;

terminal String EQUAL;
terminal String NOT_EQUAL;
terminal String LESS;
terminal String GREATER;
terminal String LESS_OR_EQUAL;
terminal String GREATER_OR_EQUAL;

terminal String ASSIGN;
terminal String LCURLY;
terminal String RCURLY;
terminal String COLON;
terminal String SEMI_COLON;
terminal String COMMA;

terminal String PRINT;
terminal String TYPE;
terminal String RETURN;

terminal String IF;
terminal String ELSE;
terminal String DEF;
terminal String FOR;
terminal String WHILE;
terminal String CONTINUE;
terminal String BREAK;

terminal String INT;
terminal String FLOAT;
terminal String STR;
terminal String LONG;
terminal String TUPLE;
terminal String LIST;
terminal String DICT;
terminal String RAW_INPUT;
terminal String HAS_KEY;
terminal String ITEMS;
terminal String KEYS;
terminal String POP;
terminal String VALUES;
terminal String COUNT;
terminal String FIND;
terminal String JOIN;
terminal String SPLIT;
terminal String REPLACE;
terminal String LENGTH;
terminal String APPEND;
terminal String EXTEND;
terminal String INDEX;
terminal String INSERT;
terminal String SIZE;
terminal String STRING;

terminal String FLOATATION;
terminal String INTEGER;
terminal String LONGATION;
terminal String IDENTIFIER;

terminal String INDENT;
terminal String DEDENT;

terminal String NEWLINE;

non terminal	program;
non terminal	module;
non terminal	simple_statement;
non terminal	simple_statement_list;
non terminal	expression;
non terminal	expression_comma_list;
non terminal	compound_statement;
non terminal	stmt_list;
non terminal	statement;
non terminal	suite;
non terminal	statement_list;
non terminal	statement_newline_list;
non terminal	key_datum;
non terminal	key_datum_comma_list;
non terminal	subscription;
non terminal	target;
non terminal	identifier_comma_list;
non terminal	expression_list;

/* Precedences */
precedence left IF, ELSE;
precedence left ASSIGN;
precedence left OR;
precedence left AND;
precedence left NOT;
precedence left LESS, GREATER, LESS_OR_EQUAL, GREATER_OR_EQUAL, EQUAL, NOT_EQUAL;
precedence left PLUS, MINUS;
precedence left MULT, DIV, DIV_INT, MOD;
precedence left SIGN;
precedence left POW;
precedence left LBRACKET, RBRACKET, LCURLY, RCURLY, LPAREN, RPAREN;

program					::= statement_newline_list:list 
								{:	RESULT = new Program((List<Statement>)list); :};
								
statement_newline_list  ::= statement:stmt statement_newline_list:list   
								{:	 
									((List<Statement>)list).add((Statement)stmt);
									RESULT = list;						
								:};
						  | NEWLINE statement_newline_list:list
					  			{:	RESULT = list; :};
						  | /* epsilon */
								{:	RESULT = new LinkedList<Statement>(); :};
								
statement_list 			::= statement:stmt statement_list:list 
								{: ((List<Statement>)list).add((Statement)stmt);
								   RESULT = list;
								:};
						  | /* epsilon */
								{: RESULT = new LinkedList<Statement>(); :};
								
statement    			::= stmt_list:list NEWLINE 
								{: RESULT = list; :};	
						  |	compound_statement:compound_stm
						  	    {:   :} ;							

stmt_list				::= simple_statement:simple SEMICOLON stmt_list:list
							{:	
								((List<Statement>)list).add((Statement)simple);
								RESULT = list;
							:};
						  | simple_statement:simple
						  	{:	
						  		List<Statement> list = new LinkedList<Statement>();
						  		list.add((Statement)simple)
						  		RESULT = list 
						  	:};
						  | /* epsilon */
						  	{:	RESULT = new LinkedList<Statement>(); :};
								
simple_statement		::= expression:expr
								{: RESULT = new ExpressionStatement((Expression)expr);	:}
						  | PRINT expression_list:list			
								{: RESULT = new Print((List<Expression>)list);	:}
						  | TYPE LPARAN expresion:expr RPARAN
								{: RESULT = new TypeExpression((Expression) expr); :}
						  | RAW_INPUT LPARAN RPARAN
								{: RESULT = new InputExpression(); :}
						  | RAW_INPUT LPARAN expression:expr RPARAN
								{: RESULT = new InputExpression((Expression) expr); :}		
						  | IDENTIFIER:value ASSIGN expression:expr
								{: RESULT = new AssignStatement(new IdentifierExpression((String)value), (Expression)expr); :}
						  |	target:value ASSIGN expression:expr
								{: RESULT = new TargetAssignStatement((Expression)value, (Expression)expr); :}
						  |	IDENTIFIER:value LPARAN expression_list:list RPARAN
								{: RESULT = new FunctionExpression(new IdentifierExpression((String)value), (LinkedList<Expression>)list);	:}		
						  | RETURN expression:expr
						  		{: RESULT = new ReturnStatement((Expression)expr);	:};

expression_list			::= expression_list:list COMMA expression:expr
								{: ((List<Expression>)list).add((Expression)expr); 
										RESULT = list;
								:}
						  |	expression:expr							
								{: List<Expression> list = new LinkedList<Expression>();
								   if((Expression)expr != null) {
								   	list.add((Expression)expr);
								   }
								   RESULT = list;
								:}
						  |	/* epsilon */
								{: RESULT = new LinkedList<Expression>();	:};		
						  		
expression				::=  MINUS expression:expr									
								{: RESULT = new UnaryExpression(UnaryOperators.sub, (Expression) expr); :} %prec SIGN
						  |	PLUS expression:expr									
								{: RESULT = new UnaryExpression(UnaryOperators.add, (Expression) expr); :} %prec SIGN
								
					  	  | expression:expr1 PLUS expression:expr2				
								{: RESULT = new BinaryExpression((Expression) expr1, BinaryOperators.add, (Expression) expr2); :}
						  |	expression:expr1 MINUS expression:expr2				
								{: RESULT = new BinaryExpression((Expression) expr1, BinaryOperators.sub, (Expression) expr2); :}
						  |	expression:expr1 MULT expression:expr2				
								{: RESULT = new BinaryExpression((Expression) expr1, BinaryOperators.mult, (Expression) expr2); :}
						  |	expression:expr1 DIV expression:expr2				
								{: RESULT = new BinaryExpression((Expression) expr1, BinaryOperators.div, (Expression) expr2); :}
						  |	expression:expr1 DIV_INT expression:expr2				
								{: RESULT = new BinaryExpression((Expression) expr1, BinaryOperators.divInt, (Expression) expr2); :}
						  |	expression:expr1 MOD expression:expr2				
								{: RESULT = new BinaryExpression((Expression) expr1, BinaryOperators.mod, (Expression) expr2); :}
						  |	expression:expr1 POW expression:expr2				
								{: RESULT = new BinaryExpression((Expression) expr1, BinaryOperators.pow, (Expression) expr2); :}
								
						  |	LPARAN expression:expr RPARAN
								{: RESULT = new ParenthesesExpression((Expression)expr); :}
						  |	LBRACKET expression_list:list RBRACKET
								{: RESULT = new ListExpression((List<Expression>)list);	:}		
								
						  |	expression:expr1 BAND expression:expr2									
								{: RESULT = new BinaryExpression((Expression) expr1, BinaryOperators.bAnd, (Expression) expr2); :}
						  |	expression:expr1 BOR expression:expr2									
								{: RESULT = new BinaryExpression((Expression) expr1, BinaryOperators.bOr, (Expression) expr2); :}
						  |	expression:expr1 BXOR expression:expr2									
								{: RESULT = new BinaryExpression((Expression) expr1, BinaryOperators.bXor, (Expression) expr2); :}
						  |	BNOT expression:expr									
								{: RESULT = new UnaryExpression(UnaryOperators.bNot, (Expression) expr); :} %prec BNOT
						  |	expression:expr1 BLSHIFT expression:expr2									
								{: RESULT = new BinaryExpression((Expression) expr1, BinaryOperators.bLShift, (Expression) expr2); :}
						  |	expression:expr1 BRSHIFT expression:expr2									
								{: RESULT = new BinaryExpression((Expression) expr1, BinaryOperators.bRShift, (Expression) expr2); :}
								
						  | TRUE
								{: RESULT = new TrueExpression(); :}
						  |	FALSE
								{: RESULT = new FalseExpression(); :}
						  
						  |	NOT expression:expr									
								{: RESULT = new UnaryExpression(UnaryOperators.not, (Expression) expr); :} %prec NOT
						  | expression:expr1 OR expression:expr2				
								{: RESULT = new BinaryExpression((Expression) expr1, BinaryOperators.or, (Expression) expr2); :}
						  |	expression:expr1 AND expression:expr2				
								{: RESULT = new BinaryExpression((Expression) expr1, BinaryOperators.and, (Expression) expr2); :}

						  | expression:expr1 LESS expression:expr2				
								{: RESULT = new BinaryExpression((Expression) expr1, BinaryOperators.less, (Expression) expr2); :}
						  |	expression:expr1 GREATER expression:expr2				
								{: RESULT = new BinaryExpression((Expression) expr1, BinaryOperators.greater, (Expression) expr2); :}
						  |	expression:expr1 EQUAL expression:expr2				
								{: RESULT = new BinaryExpression((Expression) expr1, BinaryOperators.equal, (Expression) expr2); :}
						  |	expression:expr1 GREATER_OR_EQUAL expression:expr2				
								{: RESULT = new BinaryExpression((Expression) expr1, BinaryOperators.greaterOrEqual, (Expression) expr2); :}
						  |	expression:expr1 LESS_OR_EQUAL expression:expr2				
								{: RESULT = new BinaryExpression((Expression) expr1, BinaryOperators.lessOrEqual, (Expression) expr2); :}
						  |	expression:expr1 NOT_EQUAL expression:expr2				
								{: RESULT = new BinaryExpression((Expression) expr1, BinaryOperators.notEqual, (Expression) expr2); :}
								
						  | INTEGER:value												
								{: RESULT = new IntegerExpression((String)value); :}
					  	  | FLOAT:value
								{: RESULT = new FloatExpression(((String)value)); :}	
						  | LONG:value
								{: RESULT = new LongExpression(((String)value)); :}
								
						  | IDENTIFIER:value
								{: RESULT = new IdentifierExpression((String)value); :}
								
						  | target:value
						  		{: RESULT = value; :};

								
compound_statement		::= IF expression:expr COLON suite:list1 ELSE COLON suite:list2
								{: RESULT = new IfElseStatement((Expression)expr, (List<Statement>)list1, (List<Statement>)list2); :}
						  |	IF expression:expr COLON suite:list
								{: RESULT = new IfStatement((Expression)expr, (List<Statement>)list); :}
						  |	WHILE expression:expr COLON suite:list
								{: RESULT = new WhileStatement((Expression)expr, (List<Statement>)list); :}
						  |	DEF IDENTIFIER:identifier LPARAN RPARAN COLON suite:list
								{:	interpreter.FunctionsVariables.function.add((String) identifier);
									RESULT = new FunctionDefinitionStatement((String)identifier, new LinkedList<String>(), (List<Statement>)list); 	
								:}
						  |	DEF IDENTIFIER:identifier1 LPARAN IDENTIFIER:identifier2 identifier_comma_list:identifierList RPARAN COLON suite:list
								{:	interpreter.FunctionsVariables.function.add((String) identifier1);
									((List<String>)identifierList).add((String)identifier2);
									RESULT = new FunctionDefinitionStatement((String)identifier1, (List<String>)identifierList, (List<Statement>)list); 	
								:};		

suite					::= stmt_list:list NEWLINE
								{: RESULT = (List<Statement>)list;:}
						  |	NEWLINE INDENT statement_list:list DEDENT
									{: RESULT = (List<Statement>)list;	:};	  	

target					::= IDENTIFIER LBRACKET index:i RBRACKET
								{: RESULT = new TargetExpression((Expression)expr1, (Expression)expr2); :};
								
index					::= int_expr_not_empty
								{: 				   :};
						  | int_expr : int_expr
						  		{: 				   :};
						  | int_expr : int_expr : int_expr
						  		{:				   :};								
								
int_expr				::=	int_expr_not_empty
								{:				   :};
						  | /* epsilon */
					  			{:				   :};
					  			
int_expr_not_empty		::= MINUS expression:expr									
								{: RESULT = new UnaryExpression(UnaryOperators.sub, (Expression) expr); :} %prec SIGN
						  |	PLUS expression:expr									
								{: RESULT = new UnaryExpression(UnaryOperators.add, (Expression) expr); :} %prec SIGN
								
					  	  | expression:expr1 PLUS expression:expr2				
								{: RESULT = new BinaryExpression((Expression) expr1, BinaryOperators.add, (Expression) expr2); :}
						  |	expression:expr1 MINUS expression:expr2				
								{: RESULT = new BinaryExpression((Expression) expr1, BinaryOperators.sub, (Expression) expr2); :}
						  |	expression:expr1 MULT expression:expr2				
								{: RESULT = new BinaryExpression((Expression) expr1, BinaryOperators.mult, (Expression) expr2); :}
						  |	expression:expr1 DIV expression:expr2				
								{: RESULT = new BinaryExpression((Expression) expr1, BinaryOperators.div, (Expression) expr2); :}
						  |	expression:expr1 DIV_INT expression:expr2				
								{: RESULT = new BinaryExpression((Expression) expr1, BinaryOperators.divInt, (Expression) expr2); :}
						  |	expression:expr1 MOD expression:expr2				
								{: RESULT = new BinaryExpression((Expression) expr1, BinaryOperators.mod, (Expression) expr2); :}
						  |	expression:expr1 POW expression:expr2				
								{: RESULT = new BinaryExpression((Expression) expr1, BinaryOperators.pow, (Expression) expr2); :}
								
						  |	LPARAN expression:expr RPARAN
								{: RESULT = new ParenthesesExpression((Expression)expr); :}
								
						  |	expression:expr1 BAND expression:expr2									
								{: RESULT = new BinaryExpression((Expression) expr1, BinaryOperators.bAnd, (Expression) expr2); :}
						  |	expression:expr1 BOR expression:expr2									
								{: RESULT = new BinaryExpression((Expression) expr1, BinaryOperators.bOr, (Expression) expr2); :}
						  |	expression:expr1 BXOR expression:expr2									
								{: RESULT = new BinaryExpression((Expression) expr1, BinaryOperators.bXor, (Expression) expr2); :}
						  |	BNOT expression:expr									
								{: RESULT = new UnaryExpression(UnaryOperators.bNot, (Expression) expr); :} %prec BNOT
						  |	expression:expr1 BLSHIFT expression:expr2									
								{: RESULT = new BinaryExpression((Expression) expr1, BinaryOperators.bLShift, (Expression) expr2); :}
						  |	expression:expr1 BRSHIFT expression:expr2									
								{: RESULT = new BinaryExpression((Expression) expr1, BinaryOperators.bRShift, (Expression) expr2); :}
								
						  | TRUE
								{: RESULT = new TrueExpression(); :}
						  |	FALSE
								{: RESULT = new FalseExpression(); :}
						  
						  |	NOT expression:expr									
								{: RESULT = new UnaryExpression(UnaryOperators.not, (Expression) expr); :} %prec NOT
						  | expression:expr1 OR expression:expr2				
								{: RESULT = new BinaryExpression((Expression) expr1, BinaryOperators.or, (Expression) expr2); :}
						  |	expression:expr1 AND expression:expr2				
								{: RESULT = new BinaryExpression((Expression) expr1, BinaryOperators.and, (Expression) expr2); :}

						  | expression:expr1 LESS expression:expr2				
								{: RESULT = new BinaryExpression((Expression) expr1, BinaryOperators.less, (Expression) expr2); :}
						  |	expression:expr1 GREATER expression:expr2				
								{: RESULT = new BinaryExpression((Expression) expr1, BinaryOperators.greater, (Expression) expr2); :}
						  |	expression:expr1 EQUAL expression:expr2				
								{: RESULT = new BinaryExpression((Expression) expr1, BinaryOperators.equal, (Expression) expr2); :}
						  |	expression:expr1 GREATER_OR_EQUAL expression:expr2				
								{: RESULT = new BinaryExpression((Expression) expr1, BinaryOperators.greaterOrEqual, (Expression) expr2); :}
						  |	expression:expr1 LESS_OR_EQUAL expression:expr2				
								{: RESULT = new BinaryExpression((Expression) expr1, BinaryOperators.lessOrEqual, (Expression) expr2); :}
						  |	expression:expr1 NOT_EQUAL expression:expr2				
								{: RESULT = new BinaryExpression((Expression) expr1, BinaryOperators.notEqual, (Expression) expr2); :}
								
						  | INTEGER:value												
								{: RESULT = new IntegerExpression((String)value); :}

						  | LONG:value
								{: RESULT = new LongExpression(((String)value)); :}
								
						  | IDENTIFIER:value
								{: RESULT = new IdentifierExpression((String)value); :};

								
identifier_comma_list	::= COMMA IDENTIFIER:identifier identifier_comma_list:list
								{: 
									((List<String>)list).add((String)identifier);
									RESULT = list;
								:}
						  |	/*epsilon*/
								{: RESULT = new LinkedList<String>();	:};

						  	