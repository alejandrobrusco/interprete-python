package com.language.parser;

import java.util.*;
import java_cup.runtime.*;
import com.language.*;
import com.language.model.expression.*;
import com.language.model.operators.*;
import com.language.model.statements.*;
import com.language.exceptions.*;
import com.language.types.TypeEnum;

terminal String SIGN;
terminal String PLUS;
terminal String MINUS;
terminal String POW;
terminal String MULT;
terminal String DIV_INT;
terminal String DIV;
terminal String MOD;

terminal String LPARAN;
terminal String RPARAN;
terminal String LBRACKET;
terminal String RBRACKET;

terminal String BAND;
terminal String BOR;
terminal String BXOR;
terminal String BNOT;
terminal String BLSHIFT;
terminal String BRSHIFT;

terminal String TRUE;
terminal String FALSE;

terminal String AND;
terminal String OR;
terminal String NOT;

terminal String EQUAL;
terminal String NOT_EQUAL;
terminal String LESS;
terminal String GREATER;
terminal String LESS_OR_EQUAL;
terminal String GREATER_OR_EQUAL;

terminal String ASSIGN;
terminal String LCURLY;
terminal String RCURLY;
terminal String COLON;
terminal String SEMI_COLON;
terminal String COMMA;
terminal String DOT;

terminal String PRINT;
terminal String TYPE;
terminal String RETURN;

terminal String IF;
terminal String ELSE;
terminal String DEF;
terminal String FOR;
terminal String WHILE;
terminal String CONTINUE;
terminal String BREAK;
terminal String IN;

terminal String INT;
terminal String FLOAT;
terminal String STR;
terminal String LONG;
terminal String TUPLE;
terminal String LIST;
terminal String DICT;
terminal String RAW_INPUT;

terminal String STRING;
terminal String FLOATATION;
terminal String INTEGER;
terminal String LONGER;
terminal String IDENTIFIER;

terminal String INDENT;
terminal String DEDENT;

terminal String NEWLINE;

non terminal	program;
non terminal	statement_newline_list;
non terminal	statement_list;
non terminal	statement;
non terminal	stmt_list;
non terminal	simple_statement;
non terminal	expression;
non terminal	compound_statement;
non terminal	suite;
non terminal	target;
non terminal	identifier_comma_list;
non terminal	expression_list;
non terminal	index;
non terminal	expression_or_empty;
non terminal	expression_dict_list;

/* Precedences */
precedence left IF, ELSE;
precedence left ASSIGN;
precedence left BOR;
precedence left BAND;
precedence left BNOT;
precedence left BXOR, BLSHIFT, BRSHIFT;
precedence left OR;
precedence left AND;
precedence left NOT;
precedence left LESS, GREATER, LESS_OR_EQUAL, GREATER_OR_EQUAL, EQUAL, NOT_EQUAL;
precedence left PLUS, MINUS;
precedence left MULT, DIV, DIV_INT, MOD;
precedence left SIGN;
precedence left POW;
precedence left LBRACKET, RBRACKET, LCURLY, RCURLY, LPARAN, RPARAN;
precedence left NEWLINE;

program					::= statement_newline_list:list
								{:	
									Collections.reverse((List<Statement>)list);
									RESULT = new Program((List<Statement>)list); 
								:};
								
statement_newline_list  ::= statement:stmt statement_newline_list:list   
								{:	 
									((List<Statement>)list).addAll((List<Statement>)stmt);
									RESULT = list;						
								:}
						  | NEWLINE statement_newline_list:list
					  			{:	RESULT = list; :}
						  | /* epsilon */
								{:	RESULT = new LinkedList<Statement>(); :};
								
statement_list 			::= statement:stmt statement_list:list 
								{: ((List<Statement>)list).addAll((List<Statement>)stmt);
								   RESULT = list;
								:}
						  | /* epsilon */
								{: RESULT = new LinkedList<Statement>(); :};
								
statement    			::= stmt_list:list NEWLINE 
								{: 
									Collections.reverse((List<Statement>)list);
									RESULT = list; 
								:}
						  |	compound_statement:compound_stm
						  	    {:  
						  	    	List<Statement> list = new LinkedList<Statement>();
						  	    	list.add((Statement)compound_stm);
						  	    	RESULT = list;
						  	     :} ;						

stmt_list				::= simple_statement:simple SEMI_COLON stmt_list:list
							{:	
								((List<Statement>)list).add((Statement)simple);
								RESULT = list;
							:}
						  | simple_statement:simple
						  	{:	
						  		List<Statement> list = new LinkedList<Statement>();
						  		if ((Statement)simple != null){
						  			list.add((Statement)simple);
					  			}
						  		RESULT = list; 
						  	:}
						  | /* epsilon */
						  	{:	RESULT = new LinkedList<Statement>(); :};
								
simple_statement		::= expression:expr
								{: RESULT = new ExpressionStm((Expression)expr);	:}
						  | PRINT expression_list:list			
								{: 
									Collections.reverse((List<Expression>)list);
									RESULT = new PrintStm((List<Expression>)list);	
								:}
						  | IDENTIFIER:value ASSIGN expression:expr
								{: RESULT = new AssignStm(new IdentifierExp((String)value), (Expression)expr); :}
						  |	target:value ASSIGN expression:expr
								{: RESULT = new TargetAssignStm((Expression)value, (Expression)expr); :}

						  | RETURN expression:expr
						  		{: RESULT = new ReturnStm ((Expression)expr); :}
						  		
						  | CONTINUE
						        {: RESULT = new ContinueStm(); :}
						        
						  | BREAK
						        {: RESULT = new BreakStm(); :};

expression_list			::=  expression:expr COMMA expression_list:list 
								{: ((List<Expression>)list).add((Expression)expr); 
										RESULT = list;
								:}
						  |	expression:expr							
								{: List<Expression> list = new LinkedList<Expression>();
								   if((Expression)expr != null) {
								   	list.add((Expression)expr);
								   }
								   RESULT = list;
								:}
						  |	/* epsilon */
								{: RESULT = new LinkedList<Expression>(); :};
								
expression				::=  MINUS expression:expr									
								{: RESULT = new UnaryExp(UnaryOp.sub, (Expression) expr); :} %prec SIGN
						  |	PLUS expression:expr									
								{: RESULT = new UnaryExp(UnaryOp.add, (Expression) expr); :} %prec SIGN
								
					  	  | expression:expr1 PLUS expression:expr2				
								{: RESULT = new BinaryExp((Expression) expr1, BinaryOp.add, (Expression) expr2); :}
						  |	expression:expr1 MINUS expression:expr2				
								{: RESULT = new BinaryExp((Expression) expr1, BinaryOp.sub, (Expression) expr2); :}
						  |	expression:expr1 MULT expression:expr2				
								{: RESULT = new BinaryExp((Expression) expr1, BinaryOp.mult, (Expression) expr2); :}
						  |	expression:expr1 DIV expression:expr2				
								{: RESULT = new BinaryExp((Expression) expr1, BinaryOp.div, (Expression) expr2); :}
						  |	expression:expr1 DIV_INT expression:expr2				
								{: RESULT = new BinaryExp((Expression) expr1, BinaryOp.divInt, (Expression) expr2); :}
						  |	expression:expr1 MOD expression:expr2				
								{: RESULT = new BinaryExp((Expression) expr1, BinaryOp.mod, (Expression) expr2); :}
						  |	expression:expr1 POW expression:expr2				
								{: RESULT = new BinaryExp((Expression) expr1, BinaryOp.pow, (Expression) expr2); :}
								
						  |	LPARAN expression:expr RPARAN
								{: RESULT = new ParenthesesExp((Expression)expr); :}
						  |	LPARAN expression_list:list RPARAN
								{: 
									Collections.reverse((List<Expression>)list);
									RESULT = new TupleExp((List<Expression>)list); 
								:}							
						  |	LBRACKET expression_list:list RBRACKET
								{:  
									Collections.reverse((List<Expression>)list);
									RESULT = new ListExp((List<Expression>)list);	
								:}	
						  |	LCURLY RCURLY
								{: RESULT = new DicExp(new HashMap<Expression,Expression>());	:}	
						  |	LCURLY expression:exprKey COLON expression:exprValue expression_dict_list:map RCURLY
								{: 
									((DicExp)map).put((Expression)exprKey,(Expression)exprValue);
									RESULT = map;	
								:}
								
						  |	expression:expr1 BAND expression:expr2									
								{: RESULT = new BinaryExp((Expression) expr1, BinaryOp.bAnd, (Expression) expr2); :}
						  |	expression:expr1 BOR expression:expr2									
								{: RESULT = new BinaryExp((Expression) expr1, BinaryOp.bOr, (Expression) expr2); :}
						  |	expression:expr1 BXOR expression:expr2									
								{: RESULT = new BinaryExp((Expression) expr1, BinaryOp.bXor, (Expression) expr2); :}
						  |	BNOT expression:expr									
								{: RESULT = new UnaryExp(UnaryOp.bNot, (Expression) expr); :} %prec BNOT
						  |	expression:expr1 BLSHIFT expression:expr2									
								{: RESULT = new BinaryExp((Expression) expr1, BinaryOp.bLShift, (Expression) expr2); :}
						  |	expression:expr1 BRSHIFT expression:expr2									
								{: RESULT = new BinaryExp((Expression) expr1, BinaryOp.bRShift, (Expression) expr2); :}
								
						  | TRUE
								{: RESULT = new TrueExp(); :}
						  |	FALSE
								{: RESULT = new FalseExp(); :}
						  
						  |	NOT expression:expr									
								{: RESULT = new UnaryExp(UnaryOp.not, (Expression) expr); :} %prec NOT
						  | expression:expr1 OR expression:expr2				
								{: RESULT = new BinaryExp((Expression) expr1, BinaryOp.or, (Expression) expr2); :}
						  |	expression:expr1 AND expression:expr2				
								{: RESULT = new BinaryExp((Expression) expr1, BinaryOp.and, (Expression) expr2); :}

						  | expression:expr1 LESS expression:expr2				
								{: RESULT = new BinaryExp((Expression) expr1, BinaryOp.less, (Expression) expr2); :}
						  |	expression:expr1 GREATER expression:expr2				
								{: RESULT = new BinaryExp((Expression) expr1, BinaryOp.greater, (Expression) expr2); :}
						  |	expression:expr1 EQUAL expression:expr2				
								{: RESULT = new BinaryExp((Expression) expr1, BinaryOp.equal, (Expression) expr2); :}
						  |	expression:expr1 GREATER_OR_EQUAL expression:expr2				
								{: RESULT = new BinaryExp((Expression) expr1, BinaryOp.greaterOrEqual, (Expression) expr2); :}
						  |	expression:expr1 LESS_OR_EQUAL expression:expr2				
								{: RESULT = new BinaryExp((Expression) expr1, BinaryOp.lessOrEqual, (Expression) expr2); :}
						  |	expression:expr1 NOT_EQUAL expression:expr2				
								{: RESULT = new BinaryExp((Expression) expr1, BinaryOp.notEqual, (Expression) expr2); :}
								
						  | INTEGER:value												
								{: RESULT = new IntegerExp((String)value); :}
					  	  | FLOATATION:value
								{: RESULT = new FloatExp((String)value); :}	
						  | LONGER:value
								{: RESULT = new LongExp((String)value); :}
						  | STRING:value
								{: RESULT = new StringExp((String)value); :}
						
						  | INT:value LPARAN expression_or_empty:expr RPARAN												
								{: RESULT = new TransformerExp((Expression) expr,TypeEnum.int_type); :}
					  	  | FLOAT:value LPARAN expression_or_empty:expr RPARAN
								{: RESULT = new TransformerExp((Expression)expr,TypeEnum.float_type); :}	
						  | LONG:value LPARAN expression_or_empty:expr RPARAN
								{: RESULT = new TransformerExp((Expression)expr,TypeEnum.long_type); :}
						  | STR:value LPARAN expression_or_empty:expr RPARAN
								{: RESULT = new TransformerExp((Expression)expr,TypeEnum.string_type); :}		
						  | TUPLE:value LPARAN expression_or_empty:expr RPARAN
								{: RESULT = new TransformerExp((Expression)expr,TypeEnum.tuple_type); :}	
						  | DICT:value LPARAN expression_or_empty:expr RPARAN
								{: RESULT = new TransformerExp((Expression)expr,TypeEnum.dict_type); :}
						  | LIST:value LPARAN expression_or_empty:expr RPARAN
								{: RESULT = new TransformerExp((Expression)expr,TypeEnum.list_type); :}		
								
						  | IDENTIFIER:value
								{: RESULT = new IdentifierExp((String)value); :}
								
						  | target:value
						  		{: RESULT = value; :}
						  
						  | TYPE LPARAN expression:expr RPARAN
								{: RESULT = new TypeExp((Expression) expr); :}
						  | RAW_INPUT LPARAN RPARAN
								{: RESULT = new RawInputExp(); :}
						  | RAW_INPUT LPARAN expression:expr RPARAN
								{: RESULT = new RawInputExp((Expression) expr); :}
						  |	IDENTIFIER:value LPARAN expression_list:list RPARAN
								{: RESULT = new FunctionExp (new IdentifierExp((String)value), (List<Expression>)list); :}
						  |	IDENTIFIER:value DOT IDENTIFIER:predefined LPARAN expression_list:list RPARAN
								{: RESULT = new PredefinedFunctionExp(new IdentifierExp((String)value),new IdentifierExp((String)predefined), (List<Expression>)list); :};

								
compound_statement		::= IF expression:expr COLON suite:listIf ELSE COLON suite:listElse
								{: RESULT = new IfElseStm((Expression)expr, (List<Statement>)listIf, (List<Statement>)listElse); :}
						  |	IF expression:expr COLON suite:list
								{: RESULT = new IfStm((Expression)expr, (List<Statement>)list); :}
						  |	WHILE expression:expr COLON suite:list
								{: RESULT = new WhileStm((Expression)expr, (List<Statement>)list); :}
						  |	FOR IDENTIFIER:identifier IN expression:expr COLON suite:list
								{: RESULT = new ForStm((String)identifier,(Expression)expr, (List<Statement>)list); :}
						  |	DEF IDENTIFIER:identifier LPARAN RPARAN COLON suite:list
								{:	com.language.compilador.AuxiliaryElements.functionList.add((String) identifier);
									RESULT = new FunctionDefinitionStm((String)identifier, new LinkedList<String>(), (List<Statement>)list); 	
								:}
						  |	DEF IDENTIFIER:identifier1 LPARAN IDENTIFIER:identifier2 identifier_comma_list:identifierList RPARAN COLON suite:list
								{:	com.language.compilador.AuxiliaryElements.functionList.add((String) identifier1);
									((List<String>)identifierList).add((String)identifier2);
									RESULT = new FunctionDefinitionStm((String)identifier1, (List<String>)identifierList, (List<Statement>)list); 	
								:};		

expression_dict_list	::= COMMA expression:exprKey COLON expression:exprValue expression_dict_list:map 
								{: 
									((DicExp)map).put((Expression)exprKey,(Expression)exprValue);
									RESULT = map;	
								:}
						  | /* epsilon */
						  		{: RESULT = new DicExp(new HashMap<Expression,Expression>());	:};


suite					::= stmt_list:list NEWLINE
								{: 
									Collections.reverse((List<Statement>)list);
									RESULT = (List<Statement>)list; 
								:}
						  |	NEWLINE INDENT statement_list:list DEDENT
								{: 
									Collections.reverse((List<Statement>)list);
									RESULT = (List<Statement>)list;	
								:} 
						  | NEWLINE suite:list
						        {:
						        	RESULT = (List<Statement>)list;	
						        :};	
						     
		     

target					::= IDENTIFIER:id LBRACKET index:i RBRACKET
								{: RESULT = new TargetExp((String)id,(Expression)i); :};
								
index					::= expression:expr
								{: RESULT = new IndexExp((Expression)expr); :}
						  | expression_or_empty:eIni COLON expression_or_empty:eFin
						  		{: RESULT = new IndexExp((Expression)eIni, (Expression) eFin); :}
						  | expression_or_empty:eIni COLON expression_or_empty:eFin COLON expression_or_empty:eStep
						  		{: RESULT =  new IndexExp((Expression)eIni,(Expression)eFin, (Expression)eStep); :};								
								
expression_or_empty		::=	expression:expr
								{: RESULT =	expr; :}
						  | /* epsilon */
					  			{: RESULT = new EmptyExp(); :};
					  			
identifier_comma_list	::= COMMA IDENTIFIER:identifier identifier_comma_list:list
								{: 
									((List<String>)list).add((String)identifier);
									RESULT = list;
								:}
						  |	/*epsilon*/
								{: RESULT = new LinkedList<String>();	:};

						  	